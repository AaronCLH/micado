package lava.engine.basic;

import lava.vm.VMLocation;

import java.lang.reflect.*;

/**
 * Represents a native operation that was performed to generate a fluid.
 */
class NativeOperation extends Operation {
    /**
     * The inputs.
     */
    private Object[] input;
    /**
     * The name of the native operation.
     */
    private String name;
    /**
     * Engine we're using to help with execution.
     */
    private BasicEngine engine;
    /**
     * Method we'll be invoking for this call.
     */
    private Method target;
    /**
     * Whether or not this operation produces a fluid.
     */
    private boolean outputsFluid;
    
    NativeOperation(BasicEngine engine, String name, Object[] input) {
	this.engine = engine;
	this.name = name;
	this.input = input;
	this.target = resolveTarget(engine);
    }

    int numInputs() {
	return input.length;
    }

    Object getInput(int i) {
	return input[i];
    }

    String getName() {
	return this.name;
    }

    // resolve the method that we'll be invoking
    private Method resolveTarget(BasicEngine engine) {
	Method result = null;
	Method[] methods = engine.getVM().getClass().getDeclaredMethods();
	for (int i=0; i<methods.length; i++) {
	    Method meth = methods[i];
	    // check name
	    if (!meth.getName().equals(name)) { continue; }
	    // check number of arguments.  Method might have one extra
	    // argument for return value.
	    Class[] paramTypes = meth.getParameterTypes();
	    if (paramTypes.length==input.length) {
		// in this case there are no fluids returned, so all
		// parameter types should match
		boolean match = true;
		for (int j=0; j<paramTypes.length; j++) {
		    if (!(input[j].getClass().getName().equals("lava.engine.basic.BasicFluid") && paramTypes[j].getName().equals("lava.vm.VMInputLocation") ||
			  input[j].getClass()==paramTypes[j])) {
			match = false;
			break;
		    }
		}
		if (!match) { continue; }
	    } else if (paramTypes.length==input.length+1) {
		// here, exactly one of the parameters will represent
		// the result.  It should be a VMOutputLocation.
		int numOutputs = 0;
		boolean match = true;
		for (int j=0; j<paramTypes.length; j++) {
		    if (paramTypes[j].getName().equals("lava.vm.VMOutputLocation")) {
			numOutputs++;
			if (numOutputs>1) {
			    // there shouldn't be more than one of these params
			    break;
			}
		    } else {
		    if (!(input[j-numOutputs].getClass().getName().equals("lava.engine.basic.BasicFluid") && paramTypes[j].getName().equals("lava.vm.VMInputLocation") ||
			  input[j-numOutputs].getClass()==paramTypes[j])) {
			    match=false;
			    break;
			}
		    }
		}
		if (match) {
		    // we matched when there was a fluid output
		    this.outputsFluid = true;
		} else {
		    continue;
		}
	    } else {
		// mismatching argument count
		continue;
	    }
	    // if we made it here then we have a match; select target and break
	    result = meth;
	    break;
	}
	assert result!=null : "Could not find target method for " + name;
	return result;
    }

    /**
     * Executes using an existing fluid to store any results that
     * might be generated by the execution.  <fluid> should be
     * non-null iff there are fluid outputs from this.
     */
    Object executeWithLocation(BasicFluid outputFluid) {
	assert outputsFluid == (outputFluid!=null);

	// marshal the arguments for reflection
	Class[] paramTypes = target.getParameterTypes();
	Object[] args = new Object[paramTypes.length];
	int numOutputs = 0;
	// prepare fluid I/O: ensure all fluid inputs are available,
	// and allocate storage for output fluid (if any)
	for (int i=0; i<paramTypes.length; i++) {
	    if (paramTypes[i].getName().equals("lava.vm.VMInputLocation")) {
		BasicFluid fluid = (BasicFluid)input[i-numOutputs];
		// make sure input has valid location
		fluid.ensureAvail();
		args[i] = fluid.getLocation();
	    } else if (paramTypes[i].getName().equals("lava.vm.VMOutputLocation")) {
		assert numOutputs==0 : "Don't support multiple outputs yet";
		args[i] = outputFluid.getLocation();
		numOutputs++;
	    } else {
		args[i] = input[i-numOutputs];
	    }
	}

	// find method to invoke
	Object result = null;
	try {
	    result = target.invoke(engine.getVM(), args);
	} catch (Exception e) {
	    System.err.println("Error calling native function in VM: " + name);
	    e.printStackTrace();
	    System.exit(1);
	}

	// mark fluids we used as consumed
	for (int i=0; i<input.length; i++) {
	    if (input[i] instanceof BasicFluid) {
		BasicFluid fluid = (BasicFluid)input[i];
		fluid.consume();
	    }
	}

	// if we generated a fluid in a location, make a fluid wrapper for it
	if (outputFluid!=null) {
	    result = outputFluid;
	}
	
	return result;
    }

    Object execute() {
	BasicFluid fluid = null;
	if (outputsFluid) {
	    // ensure inputs avail before taking their space
	    ensureAvailInputs();
	    VMLocation outputLoc = engine.allocateLocation();
	    fluid = new BasicFluid(engine, outputLoc, this);
	}
	return executeWithLocation(fluid);
    }

}
